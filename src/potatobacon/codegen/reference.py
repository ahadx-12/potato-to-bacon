from __future__ import annotations
from typing import Dict, List, Optional
import textwrap
import sympy as sp
import hashlib
import json


def _code_header(doc: str) -> str:
    return textwrap.dedent(
        f'''
    """
    {doc}

    Generated by potato-to-bacon reference codegen (v0.1).
    """
    '''
    )


def _format_params(free_syms: List[sp.Symbol]) -> str:
    return ", ".join(sorted([s.name for s in free_syms]))


def _expr_to_numpy(expr: sp.Basic) -> str:
    # Let NumPy handle pow/sqrt via lambdify replacements; we keep SymPy string.
    return str(sp.simplify(expr))


def generate_numpy(
    eq_or_expr: sp.Basic | sp.Equality, name: str = "compute", metadata: Optional[Dict] = None
) -> str:
    """
    If Equality -> return residual (lhs - rhs). Else return expression value.
    """
    metadata = metadata or {}
    expr = eq_or_expr.lhs - eq_or_expr.rhs if isinstance(eq_or_expr, sp.Equality) else eq_or_expr
    syms = sorted(list(expr.free_symbols), key=lambda s: s.name)
    params = _format_params(syms)
    body = _expr_to_numpy(expr)

    header = _code_header(metadata.get("doc", "Reference NumPy function"))
    meta_json = json.dumps(metadata, sort_keys=True)
    meta_hash = hashlib.sha256(meta_json.encode()).hexdigest()[:16]

    code = f'''{header}
import numpy as np

def {name}({params}):
    """
    metadata_sha: {meta_hash}
    """
    return {body}
'''
    return code
